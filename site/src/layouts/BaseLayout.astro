---
import { ViewTransitions } from "astro:transitions";
import "../styles/global.css";
import { profile } from "../data/profile";
import {
  ArrowUpRight,
  Copyright,
  Diamond,
  Compass,
  Instagram,
  Mail,
  MapPin,
  MessageCircle,
} from "lucide-react";

type JsonLd = Record<string, unknown>;

interface Props {
  title?: string;
  description?: string;
  path?: string;
  image?: string;
  noindex?: boolean;
  jsonLd?: JsonLd | JsonLd[];
}

const {
  title = `${profile.name} | ${profile.roleTitle}`,
  description = profile.summary,
  path = Astro.url.pathname,
  image = "/favicon.svg",
  noindex = false,
  jsonLd,
} = Astro.props;

const canonical = new URL(path, profile.siteUrl).toString();
const ogImage = image.startsWith("http") ? image : new URL(image, profile.siteUrl).toString();

const navItems = [
  { href: "/", label: "Home" },
  { href: "/work", label: "Work" },
  { href: "/about", label: "About" },
  { href: "/resume", label: "Resume" },
  { href: "/contact", label: "Contact" },
];

const isActive = (href: string) =>
  href === "/"
    ? Astro.url.pathname === "/"
    : Astro.url.pathname === href || Astro.url.pathname.startsWith(`${href}/`);
---

<!doctype html>
<html lang="en">
  <head>
    <!-- Critical resource priority chain -->
    <link rel="preload" as="image" href="/profile.png" fetchpriority="high" />
    <link rel="modulepreload" href="/src/pages/index.astro" />

    <!-- Prefetch next likely pages -->
    <link rel="prefetch" href="/work" />
    <link rel="prefetch" href="/contact" />

    <!-- DNS prefetch for external services -->
    <link rel="dns-prefetch" href="https://wa.me" />
    <link rel="dns-prefetch" href="https://fonts.googleapis.com" />
    <link rel="dns-prefetch" href="https://cdn.jsdelivr.net" />

    <!-- Preconnect to font CDN -->
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

    <!-- Preload critical fonts -->
    <link rel="preload" as="font" type="font/woff2"
      href="/fonts/orbitron.woff2" crossorigin />
    <meta charset="UTF-8" />
    <meta http-equiv="x-dns-prefetch-control" content="on" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{title}</title>
    <meta name="description" content={description} />
    <meta name="robots" content={noindex ? "noindex,nofollow" : "index,follow"} />
    <link rel="canonical" href={canonical} />

    <meta property="og:type" content="website" />
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:url" content={canonical} />
    <meta property="og:image" content={ogImage} />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content={title} />
    <meta name="twitter:description" content={description} />
    <meta name="twitter:image" content={ogImage} />

    {jsonLd && <script type="application/ld+json" set:html={JSON.stringify(jsonLd)} />}

    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=Poppins:wght@500;600&display=swap" rel="stylesheet" />
    <style>
      /* ── CSS VARIABLE STATE SYSTEM ── */
      :root {
        --scroll-y: 0px;
        --scroll-progress: 0;
        --viewport-w: 100vw;
        --viewport-h: 100vh;

        /* Animation easing tokens */
        --ease-out-expo: cubic-bezier(0.22, 1, 0.36, 1);
        --ease-out-back: cubic-bezier(0.34, 1.56, 0.64, 1);
        --ease-in-out: cubic-bezier(0.65, 0, 0.35, 1);
        --ease-spring: cubic-bezier(0.34, 1.3, 0.64, 1);

        /* Duration tokens */
        --dur-fast: 0.3s;
        --dur-mid: 0.7s;
        --dur-slow: 1.2s;
        --dur-cinema: 1.6s;

        /* GPU compositing defaults */
        --gpu: none;
      }

      /* ── FORCE GPU LAYERS — NEVER animate margin/padding/width/height ── */
      /* Only transform and opacity are GPU-composited */
      * {
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      /* All transitions must use ONLY transform + opacity */
      .reveal,
      .metric-card,
      .cap-card,
      .testi-card-v2,
      .work-left,
      .work-card-1,
      .work-card-2,
      .work-card-3,
      .work-card-center,
      .work-card-4 {
        will-change: transform, opacity;
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
      }

      /* Scrolling containers: own compositor layer */
      .testi-row,
      .testi-track,
      .ticker-row {
        will-change: transform;
        backface-visibility: hidden;
      }

      /* Hero: isolated paint context */
      .hero-section {
        isolation: isolate;
      }

      /* Sticky header: own layer */
      header, nav {
        backface-visibility: hidden;
      }

      /* Canvas elements: GPU rendered */
      canvas {
        will-change: transform;
      }

      @keyframes onlineHeartbeat {
        0%   { box-shadow: 0 0 4px rgba(34,197,94,0.8), 0 0 10px rgba(34,197,94,0.4); opacity: 1; }
        30%  { box-shadow: 0 0 8px rgba(34,197,94,1.0), 0 0 20px rgba(34,197,94,0.7), 0 0 35px rgba(34,197,94,0.3); opacity: 1; }
        50%  { box-shadow: 0 0 4px rgba(34,197,94,0.6), 0 0 10px rgba(34,197,94,0.3); opacity: 0.85; }
        70%  { box-shadow: 0 0 10px rgba(34,197,94,1.0), 0 0 24px rgba(34,197,94,0.8), 0 0 40px rgba(34,197,94,0.35); opacity: 1; }
        100% { box-shadow: 0 0 4px rgba(34,197,94,0.8), 0 0 10px rgba(34,197,94,0.4); opacity: 1; }
      }

      /* ── ANIMATED ICON MICRO-INTERACTIONS ── */
      @keyframes iconPop {
        0%   { transform: scale(0.7) rotate(-10deg); opacity: 0; }
        60%  { transform: scale(1.15) rotate(4deg); }
        100% { transform: scale(1) rotate(0deg); opacity: 1; }
      }

      .lucide {
        transition:
          transform 0.28s cubic-bezier(0.34, 1.5, 0.64, 1),
          filter 0.28s ease,
          opacity 0.28s ease;
        transform-origin: center;
      }

      a:hover .lucide-arrow-right,
      button:hover .lucide-arrow-right {
        transform: translateX(3px);
      }

      a:hover .lucide-arrow-up-right,
      button:hover .lucide-arrow-up-right,
      a:hover .lucide-external-link,
      button:hover .lucide-external-link {
        transform: translate(2px, -2px);
      }

      a:hover .lucide-chevron-down,
      button:hover .lucide-chevron-down {
        transform: translateY(2px);
      }

      a:hover .lucide-message-circle,
      button:hover .lucide-message-circle,
      a:hover .lucide-mail,
      button:hover .lucide-mail,
      a:hover .lucide-instagram,
      button:hover .lucide-instagram,
      a:hover .lucide-map-pin,
      button:hover .lucide-map-pin,
      a:hover .lucide-copyright,
      button:hover .lucide-copyright,
      a:hover .lucide-compass,
      button:hover .lucide-compass {
        transform: scale(1.08);
      }

      /* Icon glow on interactive elements */
      .ring-hover:hover svg,
      .glass-panel:hover svg {
        filter: drop-shadow(0 0 4px rgba(147,197,253,0.6));
      }

      a.inline-flex:hover,
      button:hover {
        box-shadow:
          0 10px 28px rgba(2, 8, 23, 0.28),
          0 0 0 1px rgba(147,197,253,0.08);
      }

      /* Capability card icon glow */
      .cap-icon-shell {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.26s cubic-bezier(0.34, 1.5, 0.64, 1), filter 0.26s ease;
        transform-origin: center;
      }

      .cap-icon-motion {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        will-change: transform;
      }

      .cap-card:hover .cap-icon {
        filter: drop-shadow(0 0 8px rgba(147,197,253,0.7));
        transition: filter 0.3s ease;
      }

      .cap-card:hover .cap-icon .cap-icon-shell {
        transform: scale(1.12);
        filter: drop-shadow(0 0 10px rgba(147,197,253,0.65));
      }

      /* Force GPU layer for animated elements — eliminates paint lag */
      .testi-track,
      .ticker-row,
      canvas {
        will-change: transform;
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
      }

      /* Smooth scroll — hardware accelerated */
      html {
        scroll-behavior: smooth;
        -webkit-overflow-scrolling: touch;
        text-rendering: optimizeSpeed;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      /* Prevent layout shift during font load */
      body {
        font-display: swap;
      }

      /* Eliminate paint on scroll for fixed/sticky elements */
      header {
        will-change: auto;
      }
      /* ── SPLASH SCREEN ── */
      @keyframes splashBeam {
        0%   { opacity: 0; transform: translateX(-50%) scaleY(0); transform-origin: top; }
        60%  { opacity: 1; transform: translateX(-50%) scaleY(1); }
        100% { opacity: 0.3; transform: translateX(-50%) scaleY(1); }
      }

      @keyframes splashProgress {
        0%   { width: 0%; }
        60%  { width: 75%; }
        85%  { width: 92%; }
        100% { width: 100%; }
      }

      @keyframes splashShimmer {
        0%   { background-position: 200% center; }
        100% { background-position: -200% center; }
      }

      @keyframes letterFill {
        0%   {
          color: transparent;
          -webkit-text-stroke: 1px rgba(147,197,253,0.25);
          text-shadow: none;
        }
        40%  {
          color: transparent;
          -webkit-text-stroke: 1px rgba(147,197,253,0.6);
          text-shadow: 0 0 20px rgba(37,99,235,0.5);
        }
        100% {
          color: #e8edf8;
          -webkit-text-stroke: 0px transparent;
          text-shadow:
            0 0 30px rgba(147,197,253,0.25),
            0 0 60px rgba(37,99,235,0.15);
        }
      }

      @keyframes splashFadeOut {
        0%   { opacity: 1; transform: scale(1); }
        100% { opacity: 0; transform: scale(1.015); }
      }

      #splash.splash-exit {
        animation: splashFadeOut 0.7s cubic-bezier(0.22,1,0.36,1) forwards;
        pointer-events: none;
      }

      /* Prevent body scroll while splash is showing */
      body.splash-active {
        overflow: hidden;
      }

      /* Force 60fps GPU compositing on all animated elements */
      .orbit-dot,
      .orbit-ring,
      .testi-track,
      .ticker-row,
      canvas {
        -webkit-backface-visibility: hidden;
        backface-visibility: hidden;
      }

      /* Prevent subpixel rendering lag on text animations */
      .reveal,
      .metric-card p,
      .cap-card p {
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        text-rendering: optimizeSpeed;
      }

      /* Contain paint to reduce repaint area */
      .hero-section {
        isolation: isolate;
      }

      /* ── VIEW TRANSITIONS — instant page navigation ── */
      ::view-transition-old(root) {
        animation: pageExit 0.18s cubic-bezier(0.22,1,0.36,1) both;
      }
      ::view-transition-new(root) {
        animation: pageEnter 0.22s cubic-bezier(0.22,1,0.36,1) both;
      }

      @keyframes pageExit {
        from { opacity: 1; transform: translateY(0) translateZ(0); }
        to   { opacity: 0; transform: translateY(-8px) translateZ(0); }
      }
      @keyframes pageEnter {
        from { opacity: 0; transform: translateY(8px) translateZ(0); }
        to   { opacity: 1; transform: translateY(0) translateZ(0); }
      }

      @media (prefers-reduced-motion: reduce) {
        ::view-transition-old(root),
        ::view-transition-new(root) {
          animation: none;
        }
      }
    </style>
    <ViewTransitions fallback="none" />
  </head>
    <body class="antialiased">

    <!-- SPLASH SCREEN — shows on first load only -->
    <div id="splash" style="
      position: fixed;
      inset: 0;
      z-index: 99999;
      background: #07090f;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      pointer-events: all;
    ">

      <!-- Star particles canvas -->
      <canvas id="splash-canvas" style="
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        opacity: 0.6;
      "></canvas>

      <!-- Vertical beam -->
      <div style="
        position: absolute;
        top: 0;
        left: 50%;
        transform: translateX(-50%);
        width: 1px;
        height: 100%;
        background: linear-gradient(180deg,
          transparent 0%,
          rgba(147,197,253,0.6) 30%,
          rgba(37,99,235,0.8) 50%,
          rgba(147,197,253,0.6) 70%,
          transparent 100%);
        animation: splashBeam 1.2s ease forwards;
        opacity: 0;
      "></div>

      <!-- Name container -->
      <div style="
        position: relative;
        z-index: 2;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0;
      ">

        <!-- Letter-by-letter name reveal -->
        <div id="splash-name" style="
          font-family: 'Orbitron', sans-serif;
          font-size: clamp(1.8rem, 6vw, 4rem);
          font-weight: 700;
          letter-spacing: 0.18em;
          color: transparent;
          position: relative;
          white-space: nowrap;
          display: flex;
          align-items: center;
          gap: 0;
        ">
          <!-- Each letter gets fill animation via JS -->
        </div>

        <!-- Glow baseline under name -->
        <div id="splash-line" style="
          height: 1px;
          width: 0%;
          margin-top: 6px;
          background: linear-gradient(90deg,
            transparent 0%,
            rgba(147,197,253,0.5) 20%,
            rgba(255,255,255,0.95) 50%,
            rgba(147,197,253,0.5) 80%,
            transparent 100%);
          box-shadow: 0 0 12px rgba(147,197,253,0.6), 0 0 28px rgba(37,99,235,0.4);
          transition: width 0.7s cubic-bezier(0.22,1,0.36,1);
        "></div>

        <!-- Tagline -->
        <p id="splash-tag" style="
          font-family: 'DM Mono', monospace;
          font-size: 0.65rem;
          letter-spacing: 0.35em;
          text-transform: uppercase;
          color: rgba(147,197,253,0);
          margin-top: 14px;
          transition: color 0.6s ease;
        ">Digital Marketing &middot; Performance &middot; Design &middot; Web Systems</p>

      </div>

      <!-- Loading bar at bottom -->
      <div style="
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 2px;
        background: rgba(255,255,255,0.04);
      ">
        <div id="splash-progress" style="
          height: 100%;
          width: 0%;
          background: linear-gradient(90deg, #2563eb, #93c5fd, #2563eb);
          background-size: 200% 100%;
          animation: splashProgress 1.4s cubic-bezier(0.22,1,0.36,1) forwards,
                     splashShimmer 1.0s linear infinite;
          box-shadow: 0 0 8px rgba(37,99,235,0.8);
        "></div>
      </div>

    </div>
    <!-- END SPLASH -->

    <!-- Noise overlay -->
    <div class="noise-overlay" aria-hidden="true"></div>

    <!-- Star field -->
    <canvas id="star-canvas" aria-hidden="true" style="
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 55vh;
      pointer-events: none;
      z-index: 0;
      opacity: 1;
      transition: opacity 0.1s linear;
    "></canvas>

    <!-- Cursor -->
    <div id="cursor-dot" aria-hidden="true"></div>
    <div id="cursor-ring" aria-hidden="true"></div>

    <!-- NAV -->
    <header class="fixed inset-x-0 top-0 z-50" style="backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px); background: rgba(7,9,15,0.28); border-bottom: 1px solid rgba(255,255,255,0.04);">

      <!-- Top micro-bar: location left, name center, status right -->
      <div class="mx-auto max-w-7xl px-6 grid grid-cols-[1fr_auto_1fr] items-center h-9 border-b" style="border-color: rgba(255,255,255,0.04);">
        <span class="text-xs font-mono tracking-widest uppercase hidden sm:block justify-self-start" style="color: rgba(147,197,253,0.45);">
          {profile.location}
          <Diamond size={9} strokeWidth={1.8} className="inline-block mx-2 align-[-1px]" />
          Available for mandates
        </span>
        <a href="/" class="justify-self-center" style="padding-left: 4px;">
          <div class="flex items-center gap-2 sm:hidden">
            <span class="hero-online-dot" style="
              width: 7px; height: 7px; border-radius: 50%; flex-shrink: 0;
              background: #22c55e;
              box-shadow: 0 0 6px rgba(34,197,94,0.9), 0 0 14px rgba(34,197,94,0.5);
              animation: onlineHeartbeat 2.4s ease-in-out infinite;
              display: inline-block;">
            </span>
            <p class="text-xs font-mono tracking-[0.22em] uppercase text-slate-300 whitespace-nowrap">
              {profile.name}
            </p>
          </div>
          <span class="hidden text-xs font-mono tracking-[0.32em] uppercase sm:inline-block" style="color: rgba(224,237,248,0.55);">
            {profile.name}
          </span>
        </a>
        <div class="hidden items-center gap-1.5 justify-self-end sm:flex">
          <div class="w-1.5 h-1.5 rounded-full bg-green-400" style="box-shadow: 0 0 6px rgba(74,222,128,0.6); opacity: 0.8;"></div>
          <span class="text-xs font-mono tracking-widest uppercase hidden sm:block" style="color: rgba(147,197,253,0.40);">Open to work</span>
        </div>
      </div>

      <!-- Main nav bar -->
      <div class="mx-auto max-w-7xl px-6 grid grid-cols-[1fr_auto_1fr] items-center h-12">

        <!-- Left: subtle home link only -->
        <a href="/" class="flex items-center group justify-self-start">
          <span class="items-center justify-center transition-colors duration-200 hidden lg:inline-flex"
            style="color: rgba(147,197,253,0.34); width: 18px; height: 18px;"
            onmouseover="this.style.color='rgba(147,197,253,0.65)'"
            onmouseout="this.style.color='rgba(147,197,253,0.34)'">
            <Compass size={14} strokeWidth={1.9} className="inline-block shrink-0" />
          </span>
        </a>

        <!-- Center: nav links -->
        <nav class="flex items-center gap-1 text-xs justify-self-center">
          {navItems.map((item) => (
            <a
              href={item.href}
              class={`rounded-full px-3.5 py-1.5 font-medium tracking-wide transition-all duration-200 ${
                isActive(item.href)
                  ? "text-white"
                  : "text-slate-500 hover:text-slate-200"
              }`}
              style={isActive(item.href) ? "background: rgba(255,255,255,0.08);" : ""}
            >
              {item.label}
            </a>
          ))}
        </nav>

        <!-- Right: WhatsApp CTA -->
        <a
          href={profile.links.whatsapp}
          target="_blank"
          rel="noreferrer"
        class="hidden sm:inline-flex items-center gap-1.5 rounded-full px-4 py-1.5 text-xs font-medium font-mono tracking-wider transition-all duration-200 hover:scale-[1.03] justify-self-end"
        style="background: rgba(37,99,235,0.20); border: 1px solid rgba(37,99,235,0.40); color: #93c5fd;"
        >
          <ArrowUpRight size={13} strokeWidth={2.2} className="inline-block shrink-0" />
          WhatsApp
        </a>
      </div>

    </header>

    <!-- MAIN -->
    <main class="flex-1 pt-[88px] container-shell">
      <slot />
    </main>

    <!-- FOOTER -->
    <footer class="mt-16 px-4 pb-10">
      <div class="mx-auto max-w-6xl glass-panel rounded-3xl px-8 py-8">
        <div class="grid gap-8 md:grid-cols-3 md:items-start">

          <!-- Identity -->
          <div class="space-y-3">
            <p class="font-display text-base font-semibold text-white">{profile.name}</p>
            <p class="text-sm text-accent-soft">{profile.roleTitle}</p>
            <p class="text-xs text-slate-500">{profile.location}</p>
          </div>

          <!-- Links -->
          <div class="space-y-2">
            <p class="text-xs uppercase tracking-widest text-slate-600 mb-3">Connect</p>
            <a href={profile.links.whatsapp} target="_blank" rel="noreferrer"
              class="flex items-center gap-2 text-sm text-slate-400 hover:text-accent-soft transition-colors">
              <MessageCircle size={14} strokeWidth={2} className="inline-block shrink-0" />
              WhatsApp &middot; {profile.whatsappDisplay}
            </a>
            <a href={profile.links.email}
              class="flex items-center gap-2 text-sm text-slate-400 hover:text-accent-soft transition-colors">
              <Mail size={14} strokeWidth={2} className="inline-block shrink-0" />
              {profile.email}
            </a>
            <a href={profile.links.instagram} target="_blank" rel="noreferrer"
              class="flex items-center gap-2 text-sm text-slate-400 hover:text-accent-soft transition-colors">
              <Instagram size={14} strokeWidth={2} className="inline-block shrink-0" />
              {profile.links.instagramHandle}
            </a>
          </div>

          <!-- Nav -->
          <div class="space-y-2">
            <p class="text-xs uppercase tracking-widest text-slate-600 mb-3">Navigate</p>
            {navItems.map((item) => (
              <a href={item.href}
                class="block text-sm text-slate-400 hover:text-white transition-colors">
                {item.label}
              </a>
            ))}
          </div>
        </div>

        <div class="mt-8 pt-6 border-t border-white/6 flex flex-col sm:flex-row items-start sm:items-center justify-between gap-3">
          <p class="text-xs text-slate-600 flex items-center gap-1.5">
            <Copyright size={12} strokeWidth={1.8} className="inline-block shrink-0" />
            <span>{new Date().getFullYear()} {profile.name} · All rights reserved.</span>
          </p>
          <p class="text-xs text-slate-700 font-mono flex items-center gap-1.5">
            <MapPin size={12} strokeWidth={1.8} className="inline-block shrink-0" />
            <span>Dubai, UAE · Available for new mandates</span>
          </p>
        </div>
      </div>
    </footer>

    <!-- Cursor JS -->
    <script is:inline>
      (() => {
        function initCursor() {
        const dot = document.getElementById("cursor-dot");
        const ring = document.getElementById("cursor-ring");
        if (!dot || !ring) return;

        let mx = -100, my = -100, rx = -100, ry = -100;
        let rafId;

        document.addEventListener("mousemove", (e) => {
          mx = e.clientX; my = e.clientY;
          dot.style.left = mx + "px";
          dot.style.top = my + "px";
        });

        const animateRing = () => {
          rx += (mx - rx) * 0.12;
          ry += (my - ry) * 0.12;
          ring.style.left = rx + "px";
          ring.style.top = ry + "px";
          rafId = requestAnimationFrame(animateRing);
        };
        animateRing();

        document.querySelectorAll("a, button, [role=button], input, textarea, select").forEach((el) => {
          el.addEventListener("mouseenter", () => document.body.classList.add("cursor-hover"));
          el.addEventListener("mouseleave", () => document.body.classList.remove("cursor-hover"));
        });

        document.addEventListener("mousedown", () => document.body.classList.add("cursor-clicking"));
        document.addEventListener("mouseup", () => document.body.classList.remove("cursor-clicking"));
        document.addEventListener("mouseleave", () => { dot.style.opacity = "0"; ring.style.opacity = "0"; });
        document.addEventListener("mouseenter", () => { dot.style.opacity = "1"; ring.style.opacity = "1"; });
        } // end initCursor
        if ('requestIdleCallback' in window) {
          requestIdleCallback(initCursor, { timeout: 1000 });
        } else {
          setTimeout(initCursor, 200);
        }
      })();
    </script>

    <!-- Reveal observer -->
    <script is:inline>
    (() => {
      // Skip on index — handled by unified observer there
      if (document.querySelector('.hero-section')) return;

      const els = document.querySelectorAll('.reveal');
      if (!els.length) return;

      // Batch all DOM reads first, then writes — prevents layout thrashing
      const readQueue  = [];
      const writeQueue = [];

      function flushQueues() {
        // READ phase — all getBoundingClientRect etc
        readQueue.forEach(fn => fn());
        readQueue.length = 0;
        // WRITE phase — all style mutations
        writeQueue.forEach(fn => fn());
        writeQueue.length = 0;
      }

      const obs = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          readQueue.push(() => {
            const delay = parseFloat(entry.target.dataset.delay || '0') * 1000;
            const el = entry.target;
            const isIntersecting = entry.isIntersecting;
            writeQueue.push(() => {
              if (isIntersecting) {
                setTimeout(() => el.classList.add('visible'), delay);
              }
            });
          });
        });
        requestAnimationFrame(flushQueues);
      }, { threshold: 0.18, rootMargin: '0px 0px -60px 0px' });

      els.forEach(el => obs.observe(el));
    })();
    </script>

    <!-- Star Field -->
    <script is:inline>
    (() => {
      const existing = window.__starFieldState || {
        canvas: null,
        ctx: null,
        W: 0,
        H: 0,
        stars: [],
        shootingStar: null,
        shootingTimer: null,
        animId: null,
        lastTime: 0,
        lastFrame: 0,
        listenersBound: false,
      };
      window.__starFieldState = existing;

      const state = existing;
      const TARGET_FPS = 60;
      const FRAME_INTERVAL = 1000 / TARGET_FPS;
      const STAR_COLOURS = [
        [214, 228, 255],
        [200, 220, 255],
        [185, 214, 255],
        [230, 238, 255],
        [162, 202, 255],
      ];

      const CFG = {
        starCount: 340,
        maxRadius: 1.5,
        minRadius: 0.18,
        twinkleSpeed: 0.008,
        twinkleVariance: 0.018,
        baseAlpha: 0.62,
        shootingStarInterval: [16000, 26000],
        shootingDuration: 1350,
        shootingTrailLength: 190,
        topBias: 0.8,
      };

      function bindCanvas() {
        state.canvas = document.getElementById('star-canvas');
        state.ctx = state.canvas ? state.canvas.getContext('2d') : null;
        return !!(state.canvas && state.ctx);
      }

      function buildStars() {
        state.stars = [];
        for (let i = 0; i < CFG.starCount; i++) {
          const col = STAR_COLOURS[Math.floor(Math.random() * STAR_COLOURS.length)];
          const yFrac = Math.pow(Math.random(), 1.55) * CFG.topBias;
          state.stars.push({
            x: Math.random() * state.W,
            y: yFrac * state.H,
            r: CFG.minRadius + Math.random() * (CFG.maxRadius - CFG.minRadius),
            alpha: CFG.baseAlpha * (0.45 + Math.random() * 0.65),
            twinkleSpeed: CFG.twinkleSpeed + (Math.random() - 0.5) * CFG.twinkleVariance,
            twinkleActive: Math.random() < 0.55,
            twinklePhase: Math.random() * Math.PI * 2,
            col,
            bright: Math.random() < 0.09,
          });
        }
      }

      function resize() {
        if (!bindCanvas()) return;
        state.W = state.canvas.width = window.innerWidth;
        state.H = state.canvas.height = window.innerHeight * 0.55;
        buildStars();
      }

      function scheduleShootingStar(delayOverride) {
        clearTimeout(state.shootingTimer);
        const [min, max] = CFG.shootingStarInterval;
        const delay = typeof delayOverride === 'number'
          ? delayOverride
          : min + Math.random() * (max - min);
        state.shootingTimer = setTimeout(launchShootingStar, delay);
      }

      function launchShootingStar() {
        if (!state.W || !state.H) return;
        const angle = (16 + Math.random() * 18) * Math.PI / 180;
        const startX = state.W * (0.12 + Math.random() * 0.5);
        const startY = state.H * (0.05 + Math.random() * 0.22);
        const speed = 300 + Math.random() * 140;

        state.shootingStar = {
          x: startX,
          y: startY,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          startTime: performance.now(),
          trailLength: CFG.shootingTrailLength + Math.random() * 70,
          width: 1.6 + Math.random() * 0.9,
        };

        scheduleShootingStar();
      }

      function drawBackground() {
        const ctx = state.ctx;
        if (!ctx) return;

        ctx.clearRect(0, 0, state.W, state.H);

        const sky = ctx.createLinearGradient(0, 0, 0, state.H);
        sky.addColorStop(0, 'rgba(18,42,102,0.34)');
        sky.addColorStop(0.25, 'rgba(14,30,86,0.18)');
        sky.addColorStop(0.6, 'rgba(7,12,28,0.04)');
        sky.addColorStop(1, 'rgba(7,9,15,0)');
        ctx.fillStyle = sky;
        ctx.fillRect(0, 0, state.W, state.H);

        const horizonGlow = ctx.createRadialGradient(
          state.W * 0.5,
          state.H * 0.16,
          0,
          state.W * 0.5,
          state.H * 0.16,
          Math.max(state.W * 0.26, 220)
        );
        horizonGlow.addColorStop(0, 'rgba(96,165,250,0.16)');
        horizonGlow.addColorStop(0.45, 'rgba(37,99,235,0.08)');
        horizonGlow.addColorStop(1, 'rgba(37,99,235,0)');
        ctx.fillStyle = horizonGlow;
        ctx.fillRect(0, 0, state.W, state.H);
      }

      function drawStars(dt) {
        const ctx = state.ctx;
        if (!ctx) return;

        state.stars.forEach((star) => {
          if (star.twinkleActive) {
            star.twinklePhase += star.twinkleSpeed * dt * 0.06;
            const wave = (Math.sin(star.twinklePhase) + 1) / 2;
            star.alpha = 0.28 + wave * (star.bright ? 0.82 : 0.58);
          }

          const [r, g, b] = star.col;
          ctx.save();

          if (star.bright && star.alpha > 0.68) {
            const glow = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, star.r * 8);
            glow.addColorStop(0, `rgba(${r},${g},${b},${(star.alpha * 0.44).toFixed(3)})`);
            glow.addColorStop(0.45, `rgba(${r},${g},${b},${(star.alpha * 0.16).toFixed(3)})`);
            glow.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.r * 8, 0, Math.PI * 2);
            ctx.fill();
          }

          ctx.globalAlpha = Math.min(star.alpha, 1);
          ctx.fillStyle = `rgb(${r},${g},${b})`;
          ctx.beginPath();
          ctx.arc(star.x, star.y, star.r, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });
      }

      function drawShootingStar(now) {
        const ctx = state.ctx;
        const ss = state.shootingStar;
        if (!ctx || !ss) return;

        const elapsed = (now - ss.startTime) / 1000;
        const totalDur = CFG.shootingDuration / 1000;
        const t = elapsed / totalDur;

        if (t >= 1) {
          state.shootingStar = null;
          return;
        }

        let alpha;
        if (t < 0.12) alpha = t / 0.12;
        else if (t < 0.76) alpha = 1;
        else alpha = 1 - (t - 0.76) / 0.24;

        const hx = ss.x + ss.vx * elapsed;
        const hy = ss.y + ss.vy * elapsed;
        const angle = Math.atan2(ss.vy, ss.vx);
        const tx = hx - Math.cos(angle) * ss.trailLength;
        const ty = hy - Math.sin(angle) * ss.trailLength;

        ctx.save();
        ctx.globalAlpha = Math.min(alpha, 1) * 0.95;
        const grad = ctx.createLinearGradient(tx, ty, hx, hy);
        grad.addColorStop(0, 'rgba(200,220,255,0)');
        grad.addColorStop(0.35, 'rgba(184,214,255,0.18)');
        grad.addColorStop(0.8, 'rgba(226,238,255,0.84)');
        grad.addColorStop(1, 'rgba(255,255,255,1)');

        ctx.strokeStyle = grad;
        ctx.lineWidth = ss.width;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(tx, ty);
        ctx.lineTo(hx, hy);
        ctx.stroke();

        const headGlow = ctx.createRadialGradient(hx, hy, 0, hx, hy, 5);
        headGlow.addColorStop(0, 'rgba(255,255,255,1)');
        headGlow.addColorStop(0.35, 'rgba(214,228,255,0.72)');
        headGlow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = headGlow;
        ctx.beginPath();
        ctx.arc(hx, hy, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      function handleScroll() {
        if (!state.canvas) return;
        const fadeOver = window.innerHeight * 0.42;
        const opacity = Math.max(0, 1 - window.scrollY / fadeOver);
        state.canvas.style.opacity = opacity.toFixed(3);
      }

      function loop(now = 0) {
        if (!bindCanvas()) return;

        const delta = now - state.lastFrame;
        if (delta < FRAME_INTERVAL - 0.5) {
          state.animId = requestAnimationFrame(loop);
          return;
        }

        state.lastFrame = now - (delta % FRAME_INTERVAL);
        const dt = now - state.lastTime;
        state.lastTime = now;

        drawBackground();
        drawStars(dt);
        drawShootingStar(now);
        state.animId = requestAnimationFrame(loop);
      }

      function refreshForNavigation() {
        resize();
        handleScroll();

        if (window.location.pathname === '/') {
          if (!state.shootingStar) {
            scheduleShootingStar(3200 + Math.random() * 2800);
          }
        }
      }

      function initStaticStars() {
        resize();
        drawBackground();
        state.stars.forEach((star) => {
          const [r, g, b] = star.col;
          state.ctx.globalAlpha = star.alpha * 0.78;
          state.ctx.fillStyle = `rgb(${r},${g},${b})`;
          state.ctx.beginPath();
          state.ctx.arc(star.x, star.y, star.r, 0, Math.PI * 2);
          state.ctx.fill();
        });
        handleScroll();
      }

      function init() {
        if (!bindCanvas()) return;

        if (!state.listenersBound) {
          state.listenersBound = true;
          window.addEventListener('resize', resize, { passive: true });
          window.addEventListener('scroll', handleScroll, { passive: true });
          window.addEventListener('pageshow', refreshForNavigation, { passive: true });
          document.addEventListener('astro:page-load', refreshForNavigation);
        }

        if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
          initStaticStars();
          return;
        }

        refreshForNavigation();

        if (!state.animId) {
          requestAnimationFrame((t) => {
            state.lastTime = t;
            state.lastFrame = t;
            loop(t);
          });
        }
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init, { once: true });
      } else {
        init();
      }
    })();
    </script>

      <!-- Splash screen controller -->
    <script is:inline>
    (() => {
      const NAME = 'MUHAMMED MUBASHIR V';
      const splash = document.getElementById('splash');
      const nameEl = document.getElementById('splash-name');
      const lineEl = document.getElementById('splash-line');
      const tagEl  = document.getElementById('splash-tag');
      if (!splash || !nameEl) return;

      const isHomePage = window.location.pathname === '/';

      // Only show splash ONCE per session
      const splashShown = sessionStorage.getItem('splash_shown');
      if (!isHomePage || splashShown) {
        splash.style.display = 'none';
        document.body.classList.remove('splash-active');
        return;
      }

      splash.style.display = 'flex';
      // Mark as shown for rest of session
      sessionStorage.setItem('splash_shown', '1');

      // Block scroll during splash
      document.body.classList.add('splash-active');

      // ── Build letter spans ──────────────────────────
      NAME.split('').forEach((char, i) => {
        const span = document.createElement('span');
        span.textContent = char === ' ' ? '\u00A0' : char;
        span.style.cssText = `
          display: inline-block;
          color: transparent;
          -webkit-text-stroke: 1px rgba(147,197,253,0.20);
          animation: letterFill 0.5s cubic-bezier(0.22,1,0.36,1) forwards;
          animation-delay: ${0.35 + i * 0.045}s;
          opacity: 0;
        `;
        // Fade letter in first
        span.style.animation = 'none';
        span.style.opacity = '0';
        span.style.transition = `opacity 0.1s ease ${0.30 + i * 0.045}s`;
        nameEl.appendChild(span);
      });

      // ── Splash canvas: small floating particles ─────
      const canvas = document.getElementById('splash-canvas');
      if (canvas) {
        const ctx = canvas.getContext('2d');
        canvas.width  = window.innerWidth;
        canvas.height = window.innerHeight;

        const particles = Array.from({ length: 60 }, () => ({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          r: 0.3 + Math.random() * 0.9,
          a: 0.1 + Math.random() * 0.5,
          speed: 0.008 + Math.random() * 0.012,
          phase: Math.random() * Math.PI * 2,
        }));

        let rafId;
        const drawParticles = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          particles.forEach(p => {
            p.phase += p.speed;
            const alpha = p.a * (0.4 + 0.6 * Math.sin(p.phase));
            ctx.globalAlpha = alpha;
            ctx.fillStyle = '#93c5fd';
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
            ctx.fill();
          });
          ctx.globalAlpha = 1;
          rafId = requestAnimationFrame(drawParticles);
        };
        drawParticles();

        // Store rafId so we can cancel it
        splash._particleRaf = rafId;
        splash._cancelParticles = () => {
          cancelAnimationFrame(rafId);
        };
      }

      // ── Animate letters in sequence ─────────────────
      const letters = nameEl.querySelectorAll('span');

      // Step 1: fade each letter in
      setTimeout(() => {
        letters.forEach((span, i) => {
          setTimeout(() => {
            span.style.opacity = '1';
            span.style.color = 'transparent';
            span.style.webkitTextStroke = '1px rgba(147,197,253,0.35)';
          }, i * 45);
        });
      }, 300);

      // Step 2: fill letters with colour (water-fill effect staggered)
      setTimeout(() => {
        letters.forEach((span, i) => {
          setTimeout(() => {
            span.style.transition = `
              color 0.45s cubic-bezier(0.22,1,0.36,1),
              text-shadow 0.45s ease,
              -webkit-text-stroke 0.3s ease
            `;
            span.style.color = '#e8edf8';
            span.style.webkitTextStroke = '0px transparent';
            span.style.textShadow = '0 0 30px rgba(147,197,253,0.3), 0 0 60px rgba(37,99,235,0.18)';
          }, i * 40);
        });

        // Expand baseline
        setTimeout(() => {
          if (lineEl) lineEl.style.width = '100%';
        }, NAME.length * 40 - 80);

        // Show tagline
        setTimeout(() => {
          if (tagEl) tagEl.style.color = 'rgba(147,197,253,0.55)';
        }, NAME.length * 40);

      }, 600);

      // ── Exit splash ──────────────────────────────────
      function exitSplash() {
        if (splash._exiting) return;
        splash._exiting = true;

        if (splash._cancelParticles) splash._cancelParticles();

        splash.classList.add('splash-exit');
        document.body.classList.remove('splash-active');

        setTimeout(() => {
          splash.style.display = 'none';
        }, 720);
      }

      // Exit when page is interactive OR after max 2.8s
      const maxTimer = setTimeout(exitSplash, 2800);

      if (document.readyState === 'interactive' || document.readyState === 'complete') {
        clearTimeout(maxTimer);
        setTimeout(exitSplash, 1800);
      } else {
        document.addEventListener('DOMContentLoaded', () => {
          clearTimeout(maxTimer);
          setTimeout(exitSplash, 1800);
        });
      }

      // If page loads faster than 1.8s still wait minimum 1.8s
      // so animation completes gracefully
      window.addEventListener('load', () => {
        clearTimeout(maxTimer);
        // Calculate how long animation needs to finish
        const minDisplay = 1800;
        const elapsed = performance.now();
        const remaining = Math.max(0, minDisplay - elapsed);
        setTimeout(exitSplash, remaining);
      });

    })();
    </script>

    <script is:inline>
    (() => {
      if (!('serviceWorker' in navigator)) return;
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js').catch(() => {});
      }, { once: true });
    })();
    </script>

    <!-- Preload all pages after first paint — instant navigation -->
    <script is:inline>
    (() => {
      function prefetchAll() {
        const pages = ['/work', '/about', '/contact', '/resume'];
        const assets = ['/profile.png', '/favicon.svg'];

        const schedule = window.requestIdleCallback || ((cb) => setTimeout(cb, 300));

        schedule(() => {
          pages.forEach(href => {
            const existing = document.querySelector(`link[href="${href}"][rel="prefetch"]`);
            if (existing) return;
            const link = document.createElement('link');
            link.rel = 'prefetch';
            link.href = href;
            link.as = 'document';
            document.head.appendChild(link);
          });

          assets.forEach(href => {
            const existing = document.querySelector(`link[href="${href}"][rel="preload"]`);
            if (existing) return;
            const link = document.createElement('link');
            link.rel = 'preload';
            link.href = href;
            link.as = href.endsWith('.png') || href.endsWith('.jpg') ? 'image' : 'image';
            document.head.appendChild(link);
          });
        }, { timeout: 2000 });

        schedule(() => {
          if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
            pages.forEach(page => {
              fetch(page, { method: 'GET', mode: 'no-cors', cache: 'force-cache' })
                .catch(() => {});
            });
          }
        }, { timeout: 3000 });
      }

      if (document.readyState === 'complete') {
        prefetchAll();
      } else {
        window.addEventListener('load', prefetchAll);
      }
    })();
    </script>

    <script is:inline>
    (() => {
      document.addEventListener('click', (e) => {
        const link = e.target.closest('a[href]');
        if (!link) return;

        const href = link.getAttribute('href');
        if (!href) return;

        const isInternal = href.startsWith('/') && !href.startsWith('//');
        const isHash = href.startsWith('#');

        if (!isInternal || isHash) return;
        if (link.target === '_blank') return;

        link.addEventListener('mouseover', () => {
          const pl = document.createElement('link');
          pl.rel = 'prefetch';
          pl.href = href;
          pl.as = 'document';
          if (!document.querySelector(`link[href="${href}"][rel="prefetch"]`)) {
            document.head.appendChild(pl);
          }
        }, { once: true });
      }, { passive: true });

      document.querySelectorAll('nav a[href]').forEach(link => {
        link.addEventListener('mouseenter', () => {
          const href = link.getAttribute('href');
          if (!href || !href.startsWith('/')) return;
          const existing = document.querySelector(`link[href="${href}"][rel="prefetch"]`);
          if (existing) return;
          const pl = document.createElement('link');
          pl.rel = 'prefetch';
          pl.href = href;
          pl.as = 'document';
          document.head.appendChild(pl);
        }, { passive: true });
      });
    })();
    </script>
  </body>
</html>




