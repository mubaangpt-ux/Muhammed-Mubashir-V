---
import "../styles/global.css";
import { profile } from "../data/profile";

type JsonLd = Record<string, unknown>;

interface Props {
  title?: string;
  description?: string;
  path?: string;
  image?: string;
  noindex?: boolean;
  jsonLd?: JsonLd | JsonLd[];
}

const {
  title = `${profile.name} | ${profile.roleTitle}`,
  description = profile.summary,
  path = Astro.url.pathname,
  image = "/favicon.svg",
  noindex = false,
  jsonLd,
} = Astro.props;

const canonical = new URL(path, profile.siteUrl).toString();
const ogImage = image.startsWith("http") ? image : new URL(image, profile.siteUrl).toString();

const navItems = [
  { href: "/", label: "Home" },
  { href: "/work", label: "Work" },
  { href: "/about", label: "About" },
  { href: "/resume", label: "Resume" },
  { href: "/contact", label: "Contact" },
];

const isActive = (href: string) =>
  href === "/"
    ? Astro.url.pathname === "/"
    : Astro.url.pathname === href || Astro.url.pathname.startsWith(`${href}/`);
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{title}</title>
    <meta name="description" content={description} />
    <meta name="robots" content={noindex ? "noindex,nofollow" : "index,follow"} />
    <link rel="canonical" href={canonical} />

    <meta property="og:type" content="website" />
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:url" content={canonical} />
    <meta property="og:image" content={ogImage} />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content={title} />
    <meta name="twitter:description" content={description} />
    <meta name="twitter:image" content={ogImage} />

    {jsonLd && <script type="application/ld+json" set:html={JSON.stringify(jsonLd)} />}
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&display=swap" rel="stylesheet" />
  </head>
  <body class="antialiased">

    <!-- Noise overlay -->
    <div class="noise-overlay" aria-hidden="true"></div>

    <!-- Star field -->
    <canvas id="star-canvas" aria-hidden="true" style="
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 55vh;
      pointer-events: none;
      z-index: 0;
      opacity: 1;
      transition: opacity 0.1s linear;
    "></canvas>

    <!-- Cursor -->
    <div id="cursor-dot" aria-hidden="true"></div>
    <div id="cursor-ring" aria-hidden="true"></div>

    <!-- NAV -->
    <header class="fixed inset-x-0 top-0 z-50" style="backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px); background: rgba(7,9,15,0.28); border-bottom: 1px solid rgba(255,255,255,0.04);">

      <!-- Top micro-bar: location left · name center · status right -->
      <div class="mx-auto max-w-7xl px-6 grid grid-cols-[1fr_auto_1fr] items-center h-9 border-b" style="border-color: rgba(255,255,255,0.04);">
        <span class="text-xs font-mono tracking-widest uppercase hidden sm:block justify-self-start" style="color: rgba(147,197,253,0.45);">
          {profile.location} &nbsp;·&nbsp; Available for mandates
        </span>
        <a href="/" class="justify-self-center">
          <span class="text-xs font-mono tracking-[0.32em] uppercase" style="color: rgba(224,237,248,0.55);">
            {profile.name}
          </span>
        </a>
        <div class="flex items-center gap-1.5 justify-self-end">
          <div class="w-1.5 h-1.5 rounded-full bg-green-400" style="box-shadow: 0 0 6px rgba(74,222,128,0.6); opacity: 0.8;"></div>
          <span class="text-xs font-mono tracking-widest uppercase hidden sm:block" style="color: rgba(147,197,253,0.40);">Open to work</span>
        </div>
      </div>

      <!-- Main nav bar -->
      <div class="mx-auto max-w-7xl px-6 grid grid-cols-[1fr_auto_1fr] items-center h-12">

        <!-- Left: subtle home link only -->
        <a href="/" class="flex items-center group justify-self-start">
          <span class="text-xs font-mono tracking-[0.3em] uppercase transition-colors duration-200 hidden lg:block"
            style="color: rgba(147,197,253,0.30);"
            onmouseover="this.style.color='rgba(147,197,253,0.65)'"
            onmouseout="this.style.color='rgba(147,197,253,0.30)'">
            ◈
          </span>
        </a>

        <!-- Center: nav links -->
        <nav class="flex items-center gap-1 text-xs justify-self-center">
          {navItems.map((item) => (
            <a
              href={item.href}
              class={`rounded-full px-3.5 py-1.5 font-medium tracking-wide transition-all duration-200 ${
                isActive(item.href)
                  ? "text-white"
                  : "text-slate-500 hover:text-slate-200"
              }`}
              style={isActive(item.href) ? "background: rgba(255,255,255,0.08);" : ""}
            >
              {item.label}
            </a>
          ))}
        </nav>

        <!-- Right: WhatsApp CTA -->
        <a
          href={profile.links.whatsapp}
          target="_blank"
          rel="noreferrer"
          class="hidden sm:inline-flex items-center gap-1.5 rounded-full px-4 py-1.5 text-xs font-medium font-mono tracking-wider transition-all duration-200 hover:scale-[1.03] justify-self-end"
          style="background: rgba(37,99,235,0.20); border: 1px solid rgba(37,99,235,0.40); color: #93c5fd;"
        >
          <span style="color: #93c5fd;">↗</span> WhatsApp
        </a>
      </div>

    </header>

    <!-- MAIN -->
    <main class="flex-1 pt-[88px] container-shell">
      <slot />
    </main>

    <!-- FOOTER -->
    <footer class="mt-16 px-4 pb-10">
      <div class="mx-auto max-w-6xl glass-panel rounded-3xl px-8 py-8">
        <div class="grid gap-8 md:grid-cols-3 md:items-start">

          <!-- Identity -->
          <div class="space-y-3">
            <p class="font-display text-base font-semibold text-white">{profile.name}</p>
            <p class="text-sm text-accent-soft">{profile.roleTitle}</p>
            <p class="text-xs text-slate-500">{profile.location}</p>
          </div>

          <!-- Links -->
          <div class="space-y-2">
            <p class="text-xs uppercase tracking-widest text-slate-600 mb-3">Connect</p>
            <a href={profile.links.whatsapp} target="_blank" rel="noreferrer"
              class="flex items-center gap-2 text-sm text-slate-400 hover:text-accent-soft transition-colors">
              <span class="text-xs text-accent-soft">↗</span> WhatsApp · {profile.whatsappDisplay}
            </a>
            <a href={profile.links.email}
              class="flex items-center gap-2 text-sm text-slate-400 hover:text-accent-soft transition-colors">
              <span class="text-xs text-accent-soft">✉</span> {profile.email}
            </a>
            <a href={profile.links.instagram} target="_blank" rel="noreferrer"
              class="flex items-center gap-2 text-sm text-slate-400 hover:text-accent-soft transition-colors">
              <span class="text-xs text-accent-soft">◎</span> {profile.links.instagramHandle}
            </a>
          </div>

          <!-- Nav -->
          <div class="space-y-2">
            <p class="text-xs uppercase tracking-widest text-slate-600 mb-3">Navigate</p>
            {navItems.map((item) => (
              <a href={item.href}
                class="block text-sm text-slate-400 hover:text-white transition-colors">
                {item.label}
              </a>
            ))}
          </div>
        </div>

        <div class="mt-8 pt-6 border-t border-white/6 flex flex-col sm:flex-row items-start sm:items-center justify-between gap-3">
          <p class="text-xs text-slate-600">© {new Date().getFullYear()} {profile.name} — All rights reserved.</p>
          <p class="text-xs text-slate-700 font-mono">Dubai, UAE · Available for new mandates</p>
        </div>
      </div>
    </footer>

    <!-- Cursor JS -->
    <script is:inline>
      (() => {
        const dot = document.getElementById("cursor-dot");
        const ring = document.getElementById("cursor-ring");
        if (!dot || !ring) return;

        let mx = -100, my = -100, rx = -100, ry = -100;
        let rafId;

        document.addEventListener("mousemove", (e) => {
          mx = e.clientX; my = e.clientY;
          dot.style.left = mx + "px";
          dot.style.top = my + "px";
        });

        const animateRing = () => {
          rx += (mx - rx) * 0.12;
          ry += (my - ry) * 0.12;
          ring.style.left = rx + "px";
          ring.style.top = ry + "px";
          rafId = requestAnimationFrame(animateRing);
        };
        animateRing();

        document.querySelectorAll("a, button, [role=button], input, textarea, select").forEach((el) => {
          el.addEventListener("mouseenter", () => document.body.classList.add("cursor-hover"));
          el.addEventListener("mouseleave", () => document.body.classList.remove("cursor-hover"));
        });

        document.addEventListener("mousedown", () => document.body.classList.add("cursor-clicking"));
        document.addEventListener("mouseup", () => document.body.classList.remove("cursor-clicking"));
        document.addEventListener("mouseleave", () => { dot.style.opacity = "0"; ring.style.opacity = "0"; });
        document.addEventListener("mouseenter", () => { dot.style.opacity = "1"; ring.style.opacity = "1"; });
      })();
    </script>

    <!-- Reveal observer -->
    <script is:inline>
      (() => {
        const els = document.querySelectorAll(".reveal");
        if (!els.length) return;
        const obs = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              const el = entry.target;
              const delay = el.getAttribute("data-delay") || "0";
              setTimeout(() => el.classList.add("visible"), parseFloat(delay) * 1000);
              obs.unobserve(el);
            }
          });
        }, { threshold: 0.12 });
        els.forEach((el) => obs.observe(el));
      })();
    </script>

    <!-- Star Field -->
    <script is:inline>
    (function () {

      const canvas = document.getElementById('star-canvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');

      // ── Config ──────────────────────────────────────────────
      const CFG = {
        starCount: 280,          // total stars
        maxRadius: 1.1,          // biggest star radius (px) — keep tiny
        minRadius: 0.15,         // smallest
        twinkleSpeed: 0.008,     // how fast alpha oscillates
        twinkleVariance: 0.018,  // randomness of twinkle speed per star
        baseAlpha: 0.55,         // resting brightness
        peakAlpha: 1.0,          // max brightness when glowing
        shootingStarInterval: [60000, 75000], // ms between shooting stars
        shootingDuration: 1400,  // ms for one shooting star
        shootingTrailLength: 180,// px
        topBias: 0.72,           // stars concentrate in top 72% of canvas
        colorVariance: true,     // subtle blue/white colour variation
      };

      // ── State ────────────────────────────────────────────────
      let W, H;
      let stars = [];
      let shootingStar = null;
      let shootingTimer = null;
      let animId = null;
      let scrollY = 0;

      // ── Resize ───────────────────────────────────────────────
      function resize() {
        W = canvas.width  = window.innerWidth;
        H = canvas.height = window.innerHeight * 0.55;
        // Regenerate stars on resize
        buildStars();
      }

      // ── Star colours ─────────────────────────────────────────
      const STAR_COLOURS = [
        [200, 220, 255],  // cool blue-white
        [210, 228, 255],  // ice white
        [180, 210, 255],  // blue
        [230, 238, 255],  // near white
        [200, 215, 255],  // pale blue
      ];

      // ── Build star array ─────────────────────────────────────
      function buildStars() {
        stars = [];
        for (let i = 0; i < CFG.starCount; i++) {
          const col = STAR_COLOURS[Math.floor(Math.random() * STAR_COLOURS.length)];
          // Bias stars toward top — sqrt pushes distribution upward
          const yFrac = Math.pow(Math.random(), 1.6) * CFG.topBias;
          stars.push({
            x: Math.random() * W,
            y: yFrac * H,
            r: CFG.minRadius + Math.random() * (CFG.maxRadius - CFG.minRadius),
            alpha: CFG.baseAlpha * (0.4 + Math.random() * 0.6),
            alphaDir: Math.random() > 0.5 ? 1 : -1,
            twinkleSpeed: CFG.twinkleSpeed + (Math.random() - 0.5) * CFG.twinkleVariance,
            // Some stars twinkle frequently, most are near-static
            twinkleActive: Math.random() < 0.45,
            twinklePhase: Math.random() * Math.PI * 2,
            col: col,
            // Rare "bright" stars
            bright: Math.random() < 0.06,
          });
        }
      }

      // ── Schedule next shooting star ──────────────────────────
      function scheduleShootingStar() {
        const [min, max] = CFG.shootingStarInterval;
        const delay = min + Math.random() * (max - min);
        shootingTimer = setTimeout(launchShootingStar, delay);
      }

      // ── Launch a shooting star ───────────────────────────────
      function launchShootingStar() {
        // Start from top area, angle 20-40° below horizontal
        const angle = (20 + Math.random() * 20) * Math.PI / 180;
        const startX = W * (0.1 + Math.random() * 0.6);
        const startY = H * (0.05 + Math.random() * 0.25);
        const speed = 280 + Math.random() * 140; // px per second

        shootingStar = {
          x: startX,
          y: startY,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          alpha: 0,
          phase: 'in',  // in → hold → out
          startTime: performance.now(),
          trailLength: CFG.shootingTrailLength + Math.random() * 60,
          width: 1.5 + Math.random() * 0.8,
        };

        scheduleShootingStar();
      }

      // ── Draw background gradient ─────────────────────────────
      function drawBackground() {
        // Deep obsidian at bottom → dark navy at top
        const grad = ctx.createLinearGradient(0, 0, 0, H);
        grad.addColorStop(0,   'rgba(6,10,26,0.0)');   // very top — transparent (let body show)
        grad.addColorStop(0.3, 'rgba(7,11,28,0.0)');
        grad.addColorStop(1,   'rgba(7,9,15,0.0)');    // seamless with body
        ctx.clearRect(0, 0, W, H);
        // Canvas is transparent — stars draw over the body gradient naturally
      }

      // ── Draw all stars ───────────────────────────────────────
      function drawStars(dt) {
        stars.forEach(star => {
          // Twinkle
          if (star.twinkleActive) {
            star.twinklePhase += star.twinkleSpeed * dt * 0.06;
            // Sine wave gives smooth oscillation
            const wave = (Math.sin(star.twinklePhase) + 1) / 2; // 0..1
            star.alpha = 0.25 + wave * (star.bright ? 0.75 : 0.55);
          }

          const [r, g, b] = star.col;
          ctx.save();

          // Bright stars get a subtle glow
          if (star.bright && star.alpha > 0.7) {
            const glow = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, star.r * 5);
            glow.addColorStop(0, `rgba(${r},${g},${b},${(star.alpha * 0.35).toFixed(3)})`);
            glow.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.r * 5, 0, Math.PI * 2);
            ctx.fill();
          }

          // Core star dot
          ctx.globalAlpha = Math.min(star.alpha, 1);
          ctx.fillStyle = `rgb(${r},${g},${b})`;
          ctx.beginPath();
          ctx.arc(star.x, star.y, star.r, 0, Math.PI * 2);
          ctx.fill();

          ctx.restore();
        });
      }

      // ── Draw shooting star ───────────────────────────────────
      function drawShootingStar(now) {
        if (!shootingStar) return;
        const ss = shootingStar;
        const elapsed = (now - ss.startTime) / 1000; // seconds
        const totalDur = CFG.shootingDuration / 1000;

        // Fade in (first 15%), full (15-75%), fade out (last 25%)
        let alpha;
        const t = elapsed / totalDur;
        if (t < 0.15)      alpha = t / 0.15;
        else if (t < 0.75) alpha = 1.0;
        else               alpha = 1 - (t - 0.75) / 0.25;

        if (t >= 1) { shootingStar = null; return; }

        // Current head position
        const hx = ss.x + ss.vx * elapsed;
        const hy = ss.y + ss.vy * elapsed;

        // Tail end (behind the head)
        const tailLen = ss.trailLength;
        const angle = Math.atan2(ss.vy, ss.vx);
        const tx = hx - Math.cos(angle) * tailLen;
        const ty = hy - Math.sin(angle) * tailLen;

        ctx.save();
        ctx.globalAlpha = Math.min(alpha, 1) * 0.92;

        // Gradient trail
        const grad = ctx.createLinearGradient(tx, ty, hx, hy);
        grad.addColorStop(0,   'rgba(200,220,255,0)');
        grad.addColorStop(0.5, 'rgba(210,228,255,0.35)');
        grad.addColorStop(0.85,'rgba(230,240,255,0.80)');
        grad.addColorStop(1,   'rgba(255,255,255,1.0)');

        ctx.strokeStyle = grad;
        ctx.lineWidth = ss.width;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(tx, ty);
        ctx.lineTo(hx, hy);
        ctx.stroke();

        // Bright head point
        const headGlow = ctx.createRadialGradient(hx, hy, 0, hx, hy, 4);
        headGlow.addColorStop(0, 'rgba(255,255,255,0.95)');
        headGlow.addColorStop(0.4, 'rgba(200,220,255,0.5)');
        headGlow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = headGlow;
        ctx.beginPath();
        ctx.arc(hx, hy, 4, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }

      // ── Scroll fade ──────────────────────────────────────────
      function handleScroll() {
        scrollY = window.scrollY;
        // Fade out over the first 40vh of scroll
        const fadeOver = window.innerHeight * 0.4;
        const opacity = Math.max(0, 1 - scrollY / fadeOver);
        canvas.style.opacity = opacity;
      }

      // ── Main loop ────────────────────────────────────────────
      let lastTime = 0;
      function loop(now) {
        const dt = now - lastTime;
        lastTime = now;

        drawBackground();
        drawStars(dt);
        drawShootingStar(now);

        animId = requestAnimationFrame(loop);
      }

      // ── Init ─────────────────────────────────────────────────
      function init() {
        resize();
        window.addEventListener('resize', resize, { passive: true });
        window.addEventListener('scroll', handleScroll, { passive: true });
        // First shooting star after 10-20s so user sees it relatively quickly
        shootingTimer = setTimeout(launchShootingStar, 10000 + Math.random() * 10000);
        requestAnimationFrame((t) => { lastTime = t; loop(t); });
      }

      // Respect reduced motion
      if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
        // Still show static stars, just no animation
        resize();
        drawBackground();
        stars.forEach(s => {
          const [r, g, b] = s.col;
          ctx.globalAlpha = s.alpha * 0.7;
          ctx.fillStyle = `rgb(${r},${g},${b})`;
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
          ctx.fill();
        });
        return;
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }

    })();
    </script>

  </body>
</html>
