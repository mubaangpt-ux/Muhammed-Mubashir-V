---
import "../styles/global.css";
import { profile } from "../data/profile";

type JsonLd = Record<string, unknown>;

interface Props {
  title?: string;
  description?: string;
  path?: string;
  image?: string;
  noindex?: boolean;
  jsonLd?: JsonLd | JsonLd[];
}

const {
  title = `${profile.name} | ${profile.roleTitle}`,
  description = profile.summary,
  path = Astro.url.pathname,
  image = "/favicon.svg",
  noindex = false,
  jsonLd,
} = Astro.props;

const canonical = new URL(path, profile.siteUrl).toString();
const ogImage = image.startsWith("http") ? image : new URL(image, profile.siteUrl).toString();

const navItems = [
  { href: "/", label: "Home" },
  { href: "/work", label: "Work" },
  { href: "/about", label: "About" },
  { href: "/resume", label: "Resume" },
  { href: "/contact", label: "Contact" },
];

const isActive = (href: string) =>
  href === "/"
    ? Astro.url.pathname === "/"
    : Astro.url.pathname === href || Astro.url.pathname.startsWith(`${href}/`);
---

<!doctype html>
<html lang="en">
  <head>
    <!-- Critical resource priority chain -->
    <link rel="preload" as="image" href="/profile.png" fetchpriority="high" />
    <link rel="modulepreload" href="/src/pages/index.astro" />

    <!-- Prefetch next likely pages -->
    <link rel="prefetch" href="/work" />
    <link rel="prefetch" href="/contact" />

    <!-- DNS prefetch for external services -->
    <link rel="dns-prefetch" href="https://wa.me" />
    <link rel="dns-prefetch" href="https://fonts.googleapis.com" />
    <link rel="dns-prefetch" href="https://cdn.jsdelivr.net" />

    <!-- Preconnect to font CDN -->
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

    <!-- Preload critical fonts -->
    <link rel="preload" as="font" type="font/woff2"
      href="/fonts/orbitron.woff2" crossorigin />
    <meta charset="UTF-8" />
    <meta http-equiv="x-dns-prefetch-control" content="on" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{title}</title>
    <meta name="description" content={description} />
    <meta name="robots" content={noindex ? "noindex,nofollow" : "index,follow"} />
    <link rel="canonical" href={canonical} />

    <meta property="og:type" content="website" />
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:url" content={canonical} />
    <meta property="og:image" content={ogImage} />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content={title} />
    <meta name="twitter:description" content={description} />
    <meta name="twitter:image" content={ogImage} />

    {jsonLd && <script type="application/ld+json" set:html={JSON.stringify(jsonLd)} />}

    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=Poppins:wght@500;600&display=swap" rel="stylesheet" />
    <style>
      /* ── CSS VARIABLE STATE SYSTEM ── */
      :root {
        --scroll-y: 0px;
        --scroll-progress: 0;
        --viewport-w: 100vw;
        --viewport-h: 100vh;

        /* Animation easing tokens */
        --ease-out-expo: cubic-bezier(0.22, 1, 0.36, 1);
        --ease-out-back: cubic-bezier(0.34, 1.56, 0.64, 1);
        --ease-in-out: cubic-bezier(0.65, 0, 0.35, 1);
        --ease-spring: cubic-bezier(0.34, 1.3, 0.64, 1);

        /* Duration tokens */
        --dur-fast: 0.3s;
        --dur-mid: 0.7s;
        --dur-slow: 1.2s;
        --dur-cinema: 1.6s;

        /* GPU compositing defaults */
        --gpu: translateZ(0);
      }

      /* ── FORCE GPU LAYERS — NEVER animate margin/padding/width/height ── */
      /* Only transform and opacity are GPU-composited */
      * {
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      /* All transitions must use ONLY transform + opacity */
      .reveal,
      .metric-card,
      .cap-card,
      .testi-card-v2,
      .work-left,
      .work-card-1,
      .work-card-2,
      .work-card-3,
      .work-card-center,
      .work-card-4 {
        transform: var(--gpu);
        will-change: transform, opacity;
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
        contain: layout style paint;
      }

      /* Scrolling containers: own compositor layer */
      .testi-row,
      .testi-track,
      .ticker-row {
        transform: var(--gpu);
        will-change: transform;
        backface-visibility: hidden;
        contain: layout style;
      }

      /* Hero: isolated paint context */
      .hero-section {
        contain: layout style paint;
        isolation: isolate;
        transform: var(--gpu);
      }

      /* Sticky header: own layer */
      header, nav {
        transform: var(--gpu);
        will-change: transform;
        backface-visibility: hidden;
        contain: layout style paint;
      }

      /* Canvas elements: GPU rendered */
      canvas {
        transform: var(--gpu);
        will-change: transform;
        image-rendering: -webkit-optimize-contrast;
        image-rendering: crisp-edges;
      }

      @keyframes onlineHeartbeat {
        0%   { box-shadow: 0 0 4px rgba(34,197,94,0.8), 0 0 10px rgba(34,197,94,0.4); opacity: 1; }
        30%  { box-shadow: 0 0 8px rgba(34,197,94,1.0), 0 0 20px rgba(34,197,94,0.7), 0 0 35px rgba(34,197,94,0.3); opacity: 1; }
        50%  { box-shadow: 0 0 4px rgba(34,197,94,0.6), 0 0 10px rgba(34,197,94,0.3); opacity: 0.85; }
        70%  { box-shadow: 0 0 10px rgba(34,197,94,1.0), 0 0 24px rgba(34,197,94,0.8), 0 0 40px rgba(34,197,94,0.35); opacity: 1; }
        100% { box-shadow: 0 0 4px rgba(34,197,94,0.8), 0 0 10px rgba(34,197,94,0.4); opacity: 1; }
      }

      /* ── ANIMATED ICON MICRO-INTERACTIONS ── */
      @keyframes iconPop {
        0%   { transform: scale(0.7) rotate(-10deg); opacity: 0; }
        60%  { transform: scale(1.15) rotate(4deg); }
        100% { transform: scale(1) rotate(0deg); opacity: 1; }
      }

      /* Arrow icons in buttons — slide on hover */
      a:hover svg,
      button:hover svg {
        animation: iconSlideRight 0.3s cubic-bezier(0.34,1.5,0.64,1) forwards;
      }

      @keyframes iconSlideRight {
        0%   { transform: translateX(0); }
        50%  { transform: translateX(3px); }
        100% { transform: translateX(0); }
      }

      /* Icon glow on interactive elements */
      .ring-hover:hover svg,
      .glass-panel:hover svg {
        filter: drop-shadow(0 0 4px rgba(147,197,253,0.6));
      }

      /* Capability card icon glow */
      .cap-card:hover .cap-icon {
        filter: drop-shadow(0 0 8px rgba(147,197,253,0.7));
        transform: scale(1.1);
        transition: filter 0.3s ease, transform 0.3s ease;
      }

      /* Force GPU layer for animated elements — eliminates paint lag */
      .hero-section,
      .testi-track,
      .ticker-row,
      canvas {
        will-change: transform;
        transform: translateZ(0);
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
      }

      /* Smooth scroll — hardware accelerated */
      html {
        scroll-behavior: smooth;
        -webkit-overflow-scrolling: touch;
        text-rendering: optimizeSpeed;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      /* Prevent layout shift during font load */
      body {
        font-display: swap;
      }

      /* Eliminate paint on scroll for fixed/sticky elements */
      header {
        will-change: transform;
        transform: translateZ(0);
        contain: layout style paint;
      }
      /* ── SPLASH SCREEN ── */
      @keyframes splashBeam {
        0%   { opacity: 0; transform: translateX(-50%) scaleY(0); transform-origin: top; }
        60%  { opacity: 1; transform: translateX(-50%) scaleY(1); }
        100% { opacity: 0.3; transform: translateX(-50%) scaleY(1); }
      }

      @keyframes splashProgress {
        0%   { width: 0%; }
        60%  { width: 75%; }
        85%  { width: 92%; }
        100% { width: 100%; }
      }

      @keyframes splashShimmer {
        0%   { background-position: 200% center; }
        100% { background-position: -200% center; }
      }

      @keyframes letterFill {
        0%   {
          color: transparent;
          -webkit-text-stroke: 1px rgba(147,197,253,0.25);
          text-shadow: none;
        }
        40%  {
          color: transparent;
          -webkit-text-stroke: 1px rgba(147,197,253,0.6);
          text-shadow: 0 0 20px rgba(37,99,235,0.5);
        }
        100% {
          color: #e8edf8;
          -webkit-text-stroke: 0px transparent;
          text-shadow:
            0 0 30px rgba(147,197,253,0.25),
            0 0 60px rgba(37,99,235,0.15);
        }
      }

      @keyframes splashFadeOut {
        0%   { opacity: 1; transform: scale(1); }
        100% { opacity: 0; transform: scale(1.015); }
      }

      #splash.splash-exit {
        animation: splashFadeOut 0.7s cubic-bezier(0.22,1,0.36,1) forwards;
        pointer-events: none;
      }

      /* Prevent body scroll while splash is showing */
      body.splash-active {
        overflow: hidden;
      }

      /* Force 60fps GPU compositing on all animated elements */
      *[style*="animation"],
      *[style*="transition"],
      .reveal,
      .metric-card,
      .cap-card,
      .work-left,
      .work-card-1,
      .work-card-2,
      .work-card-3,
      .work-card-center,
      .work-card-4,
      .testi-card,
      .testi-track,
      .orbit-dot,
      .orbit-ring,
      canvas {
        -webkit-transform: translateZ(0);
        transform: translateZ(0);
        -webkit-backface-visibility: hidden;
        backface-visibility: hidden;
      }

      /* Prevent subpixel rendering lag on text animations */
      .reveal,
      .metric-card p,
      .cap-card p {
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        text-rendering: optimizeSpeed;
      }

      /* Contain paint to reduce repaint area */
      .hero-section {
        contain: layout style paint;
        isolation: isolate;
      }
    </style>
  </head>
    <body class="antialiased">

    <!-- SPLASH SCREEN — shows on first load only -->
    <div id="splash" style="
      position: fixed;
      inset: 0;
      z-index: 99999;
      background: #07090f;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      pointer-events: all;
    ">

      <!-- Star particles canvas -->
      <canvas id="splash-canvas" style="
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        opacity: 0.6;
      "></canvas>

      <!-- Vertical beam -->
      <div style="
        position: absolute;
        top: 0;
        left: 50%;
        transform: translateX(-50%);
        width: 1px;
        height: 100%;
        background: linear-gradient(180deg,
          transparent 0%,
          rgba(147,197,253,0.6) 30%,
          rgba(37,99,235,0.8) 50%,
          rgba(147,197,253,0.6) 70%,
          transparent 100%);
        animation: splashBeam 1.2s ease forwards;
        opacity: 0;
      "></div>

      <!-- Name container -->
      <div style="
        position: relative;
        z-index: 2;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0;
      ">

        <!-- Letter-by-letter name reveal -->
        <div id="splash-name" style="
          font-family: 'Orbitron', sans-serif;
          font-size: clamp(1.8rem, 6vw, 4rem);
          font-weight: 700;
          letter-spacing: 0.18em;
          color: transparent;
          position: relative;
          white-space: nowrap;
          display: flex;
          align-items: center;
          gap: 0;
        ">
          <!-- Each letter gets fill animation via JS -->
        </div>

        <!-- Glow baseline under name -->
        <div id="splash-line" style="
          height: 1px;
          width: 0%;
          margin-top: 6px;
          background: linear-gradient(90deg,
            transparent 0%,
            rgba(147,197,253,0.5) 20%,
            rgba(255,255,255,0.95) 50%,
            rgba(147,197,253,0.5) 80%,
            transparent 100%);
          box-shadow: 0 0 12px rgba(147,197,253,0.6), 0 0 28px rgba(37,99,235,0.4);
          transition: width 0.7s cubic-bezier(0.22,1,0.36,1);
        "></div>

        <!-- Tagline -->
        <p id="splash-tag" style="
          font-family: 'DM Mono', monospace;
          font-size: 0.65rem;
          letter-spacing: 0.35em;
          text-transform: uppercase;
          color: rgba(147,197,253,0);
          margin-top: 14px;
          transition: color 0.6s ease;
        ">Digital Marketing &middot; Performance &middot; Design &middot; Web Systems</p>

      </div>

      <!-- Loading bar at bottom -->
      <div style="
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 2px;
        background: rgba(255,255,255,0.04);
      ">
        <div id="splash-progress" style="
          height: 100%;
          width: 0%;
          background: linear-gradient(90deg, #2563eb, #93c5fd, #2563eb);
          background-size: 200% 100%;
          animation: splashProgress 1.4s cubic-bezier(0.22,1,0.36,1) forwards,
                     splashShimmer 1.0s linear infinite;
          box-shadow: 0 0 8px rgba(37,99,235,0.8);
        "></div>
      </div>

    </div>
    <!-- END SPLASH -->

    <!-- Noise overlay -->
    <div class="noise-overlay" aria-hidden="true"></div>

    <!-- Star field -->
    <canvas id="star-canvas" aria-hidden="true" style="
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 55vh;
      pointer-events: none;
      z-index: 0;
      opacity: 1;
      transition: opacity 0.1s linear;
    "></canvas>

    <!-- Cursor -->
    <div id="cursor-dot" aria-hidden="true"></div>
    <div id="cursor-ring" aria-hidden="true"></div>

    <!-- NAV -->
    <header class="fixed inset-x-0 top-0 z-50" style="backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px); background: rgba(7,9,15,0.28); border-bottom: 1px solid rgba(255,255,255,0.04);">

      <!-- Top micro-bar: location left � name center � status right -->
      <div class="mx-auto max-w-7xl px-6 grid grid-cols-[1fr_auto_1fr] items-center h-9 border-b" style="border-color: rgba(255,255,255,0.04);">
        <span class="text-xs font-mono tracking-widest uppercase hidden sm:block justify-self-start" style="color: rgba(147,197,253,0.45);">
          {profile.location} &nbsp;�&nbsp; Available for mandates
        </span>
        <a href="/" class="justify-self-center" style="padding-left: 4px;">
          <div class="flex items-center gap-2 sm:hidden">
            <span class="hero-online-dot" style="
              width: 7px; height: 7px; border-radius: 50%; flex-shrink: 0;
              background: #22c55e;
              box-shadow: 0 0 6px rgba(34,197,94,0.9), 0 0 14px rgba(34,197,94,0.5);
              animation: onlineHeartbeat 2.4s ease-in-out infinite;
              display: inline-block;">
            </span>
            <p class="text-xs font-mono tracking-[0.22em] uppercase text-slate-300 whitespace-nowrap">
              {profile.name}
            </p>
          </div>
          <span class="hidden text-xs font-mono tracking-[0.32em] uppercase sm:inline-block" style="color: rgba(224,237,248,0.55);">
            {profile.name}
          </span>
        </a>
        <div class="hidden items-center gap-1.5 justify-self-end sm:flex">
          <div class="w-1.5 h-1.5 rounded-full bg-green-400" style="box-shadow: 0 0 6px rgba(74,222,128,0.6); opacity: 0.8;"></div>
          <span class="text-xs font-mono tracking-widest uppercase hidden sm:block" style="color: rgba(147,197,253,0.40);">Open to work</span>
        </div>
      </div>

      <!-- Main nav bar -->
      <div class="mx-auto max-w-7xl px-6 grid grid-cols-[1fr_auto_1fr] items-center h-12">

        <!-- Left: subtle home link only -->
        <a href="/" class="flex items-center group justify-self-start">
          <span class="text-xs font-mono tracking-[0.3em] uppercase transition-colors duration-200 hidden lg:block"
            style="color: rgba(147,197,253,0.30);"
            onmouseover="this.style.color='rgba(147,197,253,0.65)'"
            onmouseout="this.style.color='rgba(147,197,253,0.30)'">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" style="display:inline-block; animation: iconPop 0.4s ease; flex-shrink:0;">
              <path d="m12 3 1.9 5.1L19 10l-5.1 1.9L12 17l-1.9-5.1L5 10l5.1-1.9L12 3z"/>
            </svg>
          </span>
        </a>

        <!-- Center: nav links -->
        <nav class="flex items-center gap-1 text-xs justify-self-center">
          {navItems.map((item) => (
            <a
              href={item.href}
              class={`rounded-full px-3.5 py-1.5 font-medium tracking-wide transition-all duration-200 ${
                isActive(item.href)
                  ? "text-white"
                  : "text-slate-500 hover:text-slate-200"
              }`}
              style={isActive(item.href) ? "background: rgba(255,255,255,0.08);" : ""}
            >
              {item.label}
            </a>
          ))}
        </nav>

        <!-- Right: WhatsApp CTA -->
        <a
          href={profile.links.whatsapp}
          target="_blank"
          rel="noreferrer"
        class="hidden sm:inline-flex items-center gap-1.5 rounded-full px-4 py-1.5 text-xs font-medium font-mono tracking-wider transition-all duration-200 hover:scale-[1.03] justify-self-end"
        style="background: rgba(37,99,235,0.20); border: 1px solid rgba(37,99,235,0.40); color: #93c5fd;"
        >
          <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" style="display:inline-block; animation: iconPop 0.4s ease; flex-shrink:0;">
            <path d="M7 7h10v10"/><path d="M7 17 17 7"/>
          </svg>
          WhatsApp
        </a>
      </div>

    </header>

    <!-- MAIN -->
    <main class="flex-1 pt-[88px] container-shell">
      <slot />
    </main>

    <!-- FOOTER -->
    <footer class="mt-16 px-4 pb-10">
      <div class="mx-auto max-w-6xl glass-panel rounded-3xl px-8 py-8">
        <div class="grid gap-8 md:grid-cols-3 md:items-start">

          <!-- Identity -->
          <div class="space-y-3">
            <p class="font-display text-base font-semibold text-white">{profile.name}</p>
            <p class="text-sm text-accent-soft">{profile.roleTitle}</p>
            <p class="text-xs text-slate-500">{profile.location}</p>
          </div>

          <!-- Links -->
          <div class="space-y-2">
            <p class="text-xs uppercase tracking-widest text-slate-600 mb-3">Connect</p>
            <a href={profile.links.whatsapp} target="_blank" rel="noreferrer"
              class="flex items-center gap-2 text-sm text-slate-400 hover:text-accent-soft transition-colors">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:inline-block; flex-shrink:0;">
                <path d="M7 7h10v10"/><path d="M7 17 17 7"/>
              </svg>
              WhatsApp &middot; {profile.whatsappDisplay}
            </a>
            <a href={profile.links.email}
              class="flex items-center gap-2 text-sm text-slate-400 hover:text-accent-soft transition-colors">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:inline-block; flex-shrink:0;">
                <rect x="3" y="5" width="18" height="14" rx="2"/>
                <path d="m4 7 8 6 8-6"/>
              </svg>
              {profile.email}
            </a>
            <a href={profile.links.instagram} target="_blank" rel="noreferrer"
              class="flex items-center gap-2 text-sm text-slate-400 hover:text-accent-soft transition-colors">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:inline-block; flex-shrink:0;">
                <rect x="3" y="3" width="18" height="18" rx="5"/>
                <circle cx="12" cy="12" r="4"/>
                <circle cx="17.5" cy="6.5" r="1"/>
              </svg>
              {profile.links.instagramHandle}
            </a>
          </div>

          <!-- Nav -->
          <div class="space-y-2">
            <p class="text-xs uppercase tracking-widest text-slate-600 mb-3">Navigate</p>
            {navItems.map((item) => (
              <a href={item.href}
                class="block text-sm text-slate-400 hover:text-white transition-colors">
                {item.label}
              </a>
            ))}
          </div>
        </div>

        <div class="mt-8 pt-6 border-t border-white/6 flex flex-col sm:flex-row items-start sm:items-center justify-between gap-3">
          <p class="text-xs text-slate-600">� {new Date().getFullYear()} {profile.name} � All rights reserved.</p>
          <p class="text-xs text-slate-700 font-mono">Dubai, UAE � Available for new mandates</p>
        </div>
      </div>
    </footer>

    <!-- Cursor JS -->
    <script is:inline>
      (() => {
        function initCursor() {
        const dot = document.getElementById("cursor-dot");
        const ring = document.getElementById("cursor-ring");
        if (!dot || !ring) return;

        let mx = -100, my = -100, rx = -100, ry = -100;
        let rafId;

        document.addEventListener("mousemove", (e) => {
          mx = e.clientX; my = e.clientY;
          dot.style.left = mx + "px";
          dot.style.top = my + "px";
        });

        const animateRing = () => {
          rx += (mx - rx) * 0.12;
          ry += (my - ry) * 0.12;
          ring.style.left = rx + "px";
          ring.style.top = ry + "px";
          rafId = requestAnimationFrame(animateRing);
        };
        animateRing();

        document.querySelectorAll("a, button, [role=button], input, textarea, select").forEach((el) => {
          el.addEventListener("mouseenter", () => document.body.classList.add("cursor-hover"));
          el.addEventListener("mouseleave", () => document.body.classList.remove("cursor-hover"));
        });

        document.addEventListener("mousedown", () => document.body.classList.add("cursor-clicking"));
        document.addEventListener("mouseup", () => document.body.classList.remove("cursor-clicking"));
        document.addEventListener("mouseleave", () => { dot.style.opacity = "0"; ring.style.opacity = "0"; });
        document.addEventListener("mouseenter", () => { dot.style.opacity = "1"; ring.style.opacity = "1"; });
        } // end initCursor
        if ('requestIdleCallback' in window) {
          requestIdleCallback(initCursor, { timeout: 1000 });
        } else {
          setTimeout(initCursor, 200);
        }
      })();
    </script>

    <!-- Reveal observer -->
    <script is:inline>
    (() => {
      // Skip on index — handled by unified observer there
      if (document.querySelector('.hero-section')) return;

      const els = document.querySelectorAll('.reveal');
      if (!els.length) return;

      // Batch all DOM reads first, then writes — prevents layout thrashing
      const readQueue  = [];
      const writeQueue = [];

      function flushQueues() {
        // READ phase — all getBoundingClientRect etc
        readQueue.forEach(fn => fn());
        readQueue.length = 0;
        // WRITE phase — all style mutations
        writeQueue.forEach(fn => fn());
        writeQueue.length = 0;
      }

      const obs = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          readQueue.push(() => {
            const delay = parseFloat(entry.target.dataset.delay || '0') * 1000;
            const el = entry.target;
            const isIntersecting = entry.isIntersecting;
            writeQueue.push(() => {
              if (isIntersecting) {
                setTimeout(() => el.classList.add('visible'), delay);
              }
            });
          });
        });
        requestAnimationFrame(flushQueues);
      }, { threshold: 0.18, rootMargin: '0px 0px -60px 0px' });

      els.forEach(el => obs.observe(el));
    })();
    </script>

    <!-- Star Field -->
    <script is:inline>
    (function () {

      const canvas = document.getElementById('star-canvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');

      // -- Config ----------------------------------------------
      const CFG = {
        starCount: 280,          // total stars
        maxRadius: 1.1,          // biggest star radius (px) � keep tiny
        minRadius: 0.15,         // smallest
        twinkleSpeed: 0.008,     // how fast alpha oscillates
        twinkleVariance: 0.018,  // randomness of twinkle speed per star
        baseAlpha: 0.55,         // resting brightness
        peakAlpha: 1.0,          // max brightness when glowing
        shootingStarInterval: [60000, 75000], // ms between shooting stars
        shootingDuration: 1400,  // ms for one shooting star
        shootingTrailLength: 180,// px
        topBias: 0.72,           // stars concentrate in top 72% of canvas
        colorVariance: true,     // subtle blue/white colour variation
      };

      // -- State ------------------------------------------------
      let W, H;
      let stars = [];
      let shootingStar = null;
      let shootingTimer = null;
      let animId = null;
      let scrollY = 0;

      // -- Resize -----------------------------------------------
      function resize() {
        W = canvas.width  = window.innerWidth;
        H = canvas.height = window.innerHeight * 0.55;
        // Regenerate stars on resize
        buildStars();
      }

      // -- Star colours -----------------------------------------
      const STAR_COLOURS = [
        [200, 220, 255],  // cool blue-white
        [210, 228, 255],  // ice white
        [180, 210, 255],  // blue
        [230, 238, 255],  // near white
        [200, 215, 255],  // pale blue
      ];

      // -- Build star array -------------------------------------
      function buildStars() {
        stars = [];
        for (let i = 0; i < CFG.starCount; i++) {
          const col = STAR_COLOURS[Math.floor(Math.random() * STAR_COLOURS.length)];
          // Bias stars toward top � sqrt pushes distribution upward
          const yFrac = Math.pow(Math.random(), 1.6) * CFG.topBias;
          stars.push({
            x: Math.random() * W,
            y: yFrac * H,
            r: CFG.minRadius + Math.random() * (CFG.maxRadius - CFG.minRadius),
            alpha: CFG.baseAlpha * (0.4 + Math.random() * 0.6),
            alphaDir: Math.random() > 0.5 ? 1 : -1,
            twinkleSpeed: CFG.twinkleSpeed + (Math.random() - 0.5) * CFG.twinkleVariance,
            // Some stars twinkle frequently, most are near-static
            twinkleActive: Math.random() < 0.45,
            twinklePhase: Math.random() * Math.PI * 2,
            col: col,
            // Rare "bright" stars
            bright: Math.random() < 0.06,
          });
        }
      }

      // -- Schedule next shooting star --------------------------
      function scheduleShootingStar() {
        const [min, max] = CFG.shootingStarInterval;
        const delay = min + Math.random() * (max - min);
        shootingTimer = setTimeout(launchShootingStar, delay);
      }

      // -- Launch a shooting star -------------------------------
      function launchShootingStar() {
        // Start from top area, angle 20-40� below horizontal
        const angle = (20 + Math.random() * 20) * Math.PI / 180;
        const startX = W * (0.1 + Math.random() * 0.6);
        const startY = H * (0.05 + Math.random() * 0.25);
        const speed = 280 + Math.random() * 140; // px per second

        shootingStar = {
          x: startX,
          y: startY,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          alpha: 0,
          phase: 'in',  // in ? hold ? out
          startTime: performance.now(),
          trailLength: CFG.shootingTrailLength + Math.random() * 60,
          width: 1.5 + Math.random() * 0.8,
        };

        scheduleShootingStar();
      }

      // -- Draw background gradient -----------------------------
      function drawBackground() {
        // Deep obsidian at bottom ? dark navy at top
        const grad = ctx.createLinearGradient(0, 0, 0, H);
        grad.addColorStop(0,   'rgba(6,10,26,0.0)');   // very top � transparent (let body show)
        grad.addColorStop(0.3, 'rgba(7,11,28,0.0)');
        grad.addColorStop(1,   'rgba(7,9,15,0.0)');    // seamless with body
        ctx.clearRect(0, 0, W, H);
        // Canvas is transparent � stars draw over the body gradient naturally
      }

      // -- Draw all stars ---------------------------------------
      function drawStars(dt) {
        stars.forEach(star => {
          // Twinkle
          if (star.twinkleActive) {
            star.twinklePhase += star.twinkleSpeed * dt * 0.06;
            // Sine wave gives smooth oscillation
            const wave = (Math.sin(star.twinklePhase) + 1) / 2; // 0..1
            star.alpha = 0.25 + wave * (star.bright ? 0.75 : 0.55);
          }

          const [r, g, b] = star.col;
          ctx.save();

          // Bright stars get a subtle glow
          if (star.bright && star.alpha > 0.7) {
            const glow = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, star.r * 5);
            glow.addColorStop(0, `rgba(${r},${g},${b},${(star.alpha * 0.35).toFixed(3)})`);
            glow.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.r * 5, 0, Math.PI * 2);
            ctx.fill();
          }

          // Core star dot
          ctx.globalAlpha = Math.min(star.alpha, 1);
          ctx.fillStyle = `rgb(${r},${g},${b})`;
          ctx.beginPath();
          ctx.arc(star.x, star.y, star.r, 0, Math.PI * 2);
          ctx.fill();

          ctx.restore();
        });
      }

      // -- Draw shooting star -----------------------------------
      function drawShootingStar(now) {
        if (!shootingStar) return;
        const ss = shootingStar;
        const elapsed = (now - ss.startTime) / 1000; // seconds
        const totalDur = CFG.shootingDuration / 1000;

        // Fade in (first 15%), full (15-75%), fade out (last 25%)
        let alpha;
        const t = elapsed / totalDur;
        if (t < 0.15)      alpha = t / 0.15;
        else if (t < 0.75) alpha = 1.0;
        else               alpha = 1 - (t - 0.75) / 0.25;

        if (t >= 1) { shootingStar = null; return; }

        // Current head position
        const hx = ss.x + ss.vx * elapsed;
        const hy = ss.y + ss.vy * elapsed;

        // Tail end (behind the head)
        const tailLen = ss.trailLength;
        const angle = Math.atan2(ss.vy, ss.vx);
        const tx = hx - Math.cos(angle) * tailLen;
        const ty = hy - Math.sin(angle) * tailLen;

        ctx.save();
        ctx.globalAlpha = Math.min(alpha, 1) * 0.92;

        // Gradient trail
        const grad = ctx.createLinearGradient(tx, ty, hx, hy);
        grad.addColorStop(0,   'rgba(200,220,255,0)');
        grad.addColorStop(0.5, 'rgba(210,228,255,0.35)');
        grad.addColorStop(0.85,'rgba(230,240,255,0.80)');
        grad.addColorStop(1,   'rgba(255,255,255,1.0)');

        ctx.strokeStyle = grad;
        ctx.lineWidth = ss.width;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(tx, ty);
        ctx.lineTo(hx, hy);
        ctx.stroke();

        // Bright head point
        const headGlow = ctx.createRadialGradient(hx, hy, 0, hx, hy, 4);
        headGlow.addColorStop(0, 'rgba(255,255,255,0.95)');
        headGlow.addColorStop(0.4, 'rgba(200,220,255,0.5)');
        headGlow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = headGlow;
        ctx.beginPath();
        ctx.arc(hx, hy, 4, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }

      // -- Scroll fade ------------------------------------------
      function handleScroll() {
        scrollY = window.scrollY;
        // Fade out over the first 40vh of scroll
        const fadeOver = window.innerHeight * 0.4;
        const opacity = Math.max(0, 1 - scrollY / fadeOver);
        canvas.style.opacity = opacity;
      }

      // -- Main loop --------------------------------------------
      let lastTime = 0;
      let lastFrame = 0;
      const TARGET_FPS = 60;
      const FRAME_INTERVAL = 1000 / TARGET_FPS;
      function loop(now = 0) {
        const delta = now - lastFrame;
        if (delta < FRAME_INTERVAL - 0.5) {
          animId = requestAnimationFrame(loop);
          return;
        }
        lastFrame = now - (delta % FRAME_INTERVAL);
        const dt = now - lastTime;
        lastTime = now;

        drawBackground();
        drawStars(dt);
        drawShootingStar(now);

        animId = requestAnimationFrame(loop);
      }

      // -- Init -------------------------------------------------
      function init() {
        resize();
        window.addEventListener('resize', resize, { passive: true });
        window.addEventListener('scroll', handleScroll, { passive: true });
        // First shooting star after 10-20s so user sees it relatively quickly
        shootingTimer = setTimeout(launchShootingStar, 10000 + Math.random() * 10000);
        requestAnimationFrame((t) => { lastTime = t; lastFrame = t; loop(t); });
      }

      // Respect reduced motion
      if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
        // Still show static stars, just no animation
        resize();
        drawBackground();
        stars.forEach(s => {
          const [r, g, b] = s.col;
          ctx.globalAlpha = s.alpha * 0.7;
          ctx.fillStyle = `rgb(${r},${g},${b})`;
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
          ctx.fill();
        });
        return;
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }

    })();
    </script>

      <!-- Splash screen controller -->
    <script is:inline>
    (() => {
      const NAME = 'MUHAMMED MUBASHIR V';
      const splash = document.getElementById('splash');
      const nameEl = document.getElementById('splash-name');
      const lineEl = document.getElementById('splash-line');
      const tagEl  = document.getElementById('splash-tag');
      if (!splash || !nameEl) return;

      // Block scroll during splash
      document.body.classList.add('splash-active');

      // ── Build letter spans ──────────────────────────
      NAME.split('').forEach((char, i) => {
        const span = document.createElement('span');
        span.textContent = char === ' ' ? '\u00A0' : char;
        span.style.cssText = `
          display: inline-block;
          color: transparent;
          -webkit-text-stroke: 1px rgba(147,197,253,0.20);
          animation: letterFill 0.5s cubic-bezier(0.22,1,0.36,1) forwards;
          animation-delay: ${0.35 + i * 0.045}s;
          opacity: 0;
        `;
        // Fade letter in first
        span.style.animation = 'none';
        span.style.opacity = '0';
        span.style.transition = `opacity 0.1s ease ${0.30 + i * 0.045}s`;
        nameEl.appendChild(span);
      });

      // ── Splash canvas: small floating particles ─────
      const canvas = document.getElementById('splash-canvas');
      if (canvas) {
        const ctx = canvas.getContext('2d');
        canvas.width  = window.innerWidth;
        canvas.height = window.innerHeight;

        const particles = Array.from({ length: 60 }, () => ({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          r: 0.3 + Math.random() * 0.9,
          a: 0.1 + Math.random() * 0.5,
          speed: 0.008 + Math.random() * 0.012,
          phase: Math.random() * Math.PI * 2,
        }));

        let rafId;
        const drawParticles = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          particles.forEach(p => {
            p.phase += p.speed;
            const alpha = p.a * (0.4 + 0.6 * Math.sin(p.phase));
            ctx.globalAlpha = alpha;
            ctx.fillStyle = '#93c5fd';
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
            ctx.fill();
          });
          ctx.globalAlpha = 1;
          rafId = requestAnimationFrame(drawParticles);
        };
        drawParticles();

        // Store rafId so we can cancel it
        splash._particleRaf = rafId;
        splash._cancelParticles = () => {
          cancelAnimationFrame(rafId);
        };
      }

      // ── Animate letters in sequence ─────────────────
      const letters = nameEl.querySelectorAll('span');

      // Step 1: fade each letter in
      setTimeout(() => {
        letters.forEach((span, i) => {
          setTimeout(() => {
            span.style.opacity = '1';
            span.style.color = 'transparent';
            span.style.webkitTextStroke = '1px rgba(147,197,253,0.35)';
          }, i * 45);
        });
      }, 300);

      // Step 2: fill letters with colour (water-fill effect staggered)
      setTimeout(() => {
        letters.forEach((span, i) => {
          setTimeout(() => {
            span.style.transition = `
              color 0.45s cubic-bezier(0.22,1,0.36,1),
              text-shadow 0.45s ease,
              -webkit-text-stroke 0.3s ease
            `;
            span.style.color = '#e8edf8';
            span.style.webkitTextStroke = '0px transparent';
            span.style.textShadow = '0 0 30px rgba(147,197,253,0.3), 0 0 60px rgba(37,99,235,0.18)';
          }, i * 40);
        });

        // Expand baseline
        setTimeout(() => {
          if (lineEl) lineEl.style.width = '100%';
        }, NAME.length * 40 - 80);

        // Show tagline
        setTimeout(() => {
          if (tagEl) tagEl.style.color = 'rgba(147,197,253,0.55)';
        }, NAME.length * 40);

      }, 600);

      // ── Exit splash ──────────────────────────────────
      function exitSplash() {
        if (splash._exiting) return;
        splash._exiting = true;

        if (splash._cancelParticles) splash._cancelParticles();

        splash.classList.add('splash-exit');
        document.body.classList.remove('splash-active');

        setTimeout(() => {
          splash.style.display = 'none';
        }, 720);
      }

      // Exit when page is interactive OR after max 2.8s
      const maxTimer = setTimeout(exitSplash, 2800);

      if (document.readyState === 'interactive' || document.readyState === 'complete') {
        clearTimeout(maxTimer);
        setTimeout(exitSplash, 1800);
      } else {
        document.addEventListener('DOMContentLoaded', () => {
          clearTimeout(maxTimer);
          setTimeout(exitSplash, 1800);
        });
      }

      // If page loads faster than 1.8s still wait minimum 1.8s
      // so animation completes gracefully
      window.addEventListener('load', () => {
        clearTimeout(maxTimer);
        // Calculate how long animation needs to finish
        const minDisplay = 1800;
        const elapsed = performance.now();
        const remaining = Math.max(0, minDisplay - elapsed);
        setTimeout(exitSplash, remaining);
      });

    })();
    </script>
    <script is:inline src="https://unpkg.com/@dotlottie/player-component@latest/dist/dotlottie-player.js"></script>
    <script is:inline>
      (function initLenis() {
        // Dynamically import Lenis only after page is interactive
        if (!('requestIdleCallback' in window)) {
          window.requestIdleCallback = (cb) => setTimeout(cb, 1);
        }

        requestIdleCallback(() => {
          import('https://cdn.jsdelivr.net/npm/lenis@1.1.13/dist/lenis.mjs').then(({ default: Lenis }) => {
            const lenis = new Lenis({
              duration: 1.25,
              easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
              smoothWheel: true,
              syncTouch: false,
              touchMultiplier: 1.8,
            });

            // Store globally so other scripts can access scroll values
            window.__lenis = lenis;

            // Tick with rAF
            function raf(time) {
              lenis.raf(time);
              requestAnimationFrame(raf);
            }
            requestAnimationFrame(raf);

            // Emit scroll value as CSS variable — zero JS style thrashing
            lenis.on('scroll', ({ scroll, progress }) => {
              document.documentElement.style.setProperty('--scroll-y', scroll + 'px');
              document.documentElement.style.setProperty('--scroll-progress', progress.toFixed(4));
            });
          });
        }, { timeout: 500 });
      })();
    </script>
  </body>
</html>




